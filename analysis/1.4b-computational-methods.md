# 1.4b Computational Methods

Computational methods allow you to create an efficient and useful solution and help your project remain easy to understand even when it gets quite big. I will use computational methods in my game to make development easier and improve the player's experience.

## Thinking Abstractly and Visualisation

Thinking abstractly involves devising a model that represents reality and removing details that are not relevant to the problem at hand. By visualizing abstract concepts, they can become more concrete and easier to grasp. Furthermore, abstraction reduces complexity, improves efficiency, and promotes code reusability.

Elements I can abstract in my game include:

* Graphics are abstracted down to a basic pixel art style with sprites and textures because my game doesn't need to have brilliant graphics to be enjoyable.
* Real-life limitations such as fatigue or hunger will not affect the player as these functions are not necessary for my game.
* Enemies will follow an algorithm which makes them move towards and attack the player. This is much simpler than using something like a neural network for example.
* The combat rooms will be as basic as possible, consisting of only enemies, walls, destructible blocks and occasionally spike traps.
* I will prioritize a simple and streamlined user interface that only presents necessary menus and information. By doing so, players will be able to easily understand and access important features, improving their overall experience.

## Thinking Ahead

Thinking ahead involves planning inputs and outputs, determining pre-conditions for solving a problem and considering the need for reusable program components. Thinking ahead is important because it enables you to visualize the ideal end result for your game and plan the steps required to reach it. This allows you to better manage your time and resources and work more efficiently towards the end product.

When designing my game, it is essential that I take a forward-thinking approach and consider all the tasks required to create my game. For example, developing a structured plan beforehand will allow me to effectively manage my time more effectively and prioritise important tasks. Additionally, this will allow me to identify potential issues with each section individually. By doing this, I'll be able to prevent small issues from escalating into larger problems that could be more difficult to solve later on. What's more, this will help me maximize my productivity by minimising the risk of getting sidetracked and working on a detail which is not as important.

I also need to outline the different inputs and outputs the game requires, and how they affect the game. It's important to remember the game's inputs - the controls - are likely to remain constant throughout the development process as they are a core part of the game's design. Based on these inputs I can then determine how they will translate into various outputs for my game to function. Outputs can include the movement of the player and where the player shoots for example. Taking this approach will help the game feel intuitive for players and also make it smoother behind the scenes.

## Thinking Procedurally and Decomposition

Thinking procedurally involves simplifying programming by breaking down a problem into smaller, more manageable parts: a technique known as decomposition. This approach makes it simpler to understand and design the smaller subproblems, resulting in a more efficient program. Through decomposition, a large and complicated problem can be continuously broken down into smaller subproblems that are simpler to solve.

During the design of my game, it is important that I use decomposition to streamline my workflow and prevent me from becoming overwhelmed. When the sub-tasks come together my program should function as intended.

## Thinking Logically

Logical thinking involves analysing a situation or problem and developing potential solutions. It also involves recognising where the user needs to make decisions within the program and mapping out the potential consequences of those decisions.

There will be many choices that the player can make in my game, so the program needs to respond logically to whatever the player decides to do.

* The player may choose to buy items or powerups from the shop so the game must respond accordingly by giving the player what they purchased.
* Players can choose which weapon they use so my game needs to ensure that the gun's skin and mechanics are correct.
* The game should be constantly checking for if any controls have been pressed while ignoring any invalid key presses.
* The player could try to return to the previous rooms which they have already cleared. I need to make sure the game does not spawn enemies again.

## Thinking Concurrently

Concurrent thinking refers to the ability to accomplish multiple tasks at the same time, but it doesn't necessarily imply that you must work on several tasks simultaneously. My game will have to execute multiple tasks in each frame.

* Sound effects need to coincide with in-game actions for example when an enemy is killed a sound effect should be played.
* Every time the player kills an enemy or opens a chest the game needs to keep track of it so that it can be displayed at the end of the dungeon along with other relevant statistics.
* Multiple enemies will be present in the same room therefore it is important for the movement of each enemy to be operated concurrently.
* The game must keep track of how many coins and health points the player has and adjust them accordingly.
* The program needs to keep track of hitboxes to determine if they interact and react accordingly.
