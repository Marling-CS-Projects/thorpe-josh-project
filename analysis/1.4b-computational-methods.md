# 1.4b Computational Methods

Effectively using computational methods allows you to create a useful, efficient solution to a task and helps during development by keeping the project easy to understand even when it gets quite big. I will use computational methods while making my game to make development simpler and ultimately create a better game for the player since I will be able to spend more time on the important things.

## Thinking Abstractly and Visualisation

Thinking abstractly involves devising a model that removes irrelevant details from the problem at hand and using this to solve the bigger problem. By visualizing abstract concepts, they can become more concrete and easier to grasp. Furthermore, abstraction reduces complexity, improves efficiency, and promotes code reusability. This helps save time and effort since developers can make use of existing abstractions rather than having to come up with something complex entirely from scratch each time they face a new problem.

Elements I can abstract in my game include:

* Graphics are abstracted down to a basic pixel art style with sprites and textures because my game doesn't need to have brilliant graphics to be enjoyable, as long as the gameplay is exciting and engaging.
* Real-life limitations such as fatigue or hunger will not affect the player as these functions are not necessary for my game.
* Enemy movement will follow the rules of a basic algorithm which makes them move towards and attack the player. This approach is much simpler than using something complex like a neural network.
* The combat rooms will be as basic as possible, consisting of only enemies, walls, destructible blocks and occasionally spike traps.
* I will prioritize a simple and streamlined user interface that only presents necessary menus and information. By doing so, players will be able to easily understand and access important features, improving their overall experience.

## Thinking Ahead

Thinking ahead involves planning inputs and outputs, determining pre-conditions for solving a problem and considering the need for reusable program components. Thinking ahead is important because it enables you to better visualize and plan the ideal end product.

When designing my game, it's essential that I take this approach. For example, developing a structured plan beforehand will allow me to manage my time more effectively and prioritise important tasks. Additionally, I'll be able to identify potential issues with each subsection of the project individually. By doing this, I'll be able to prevent small issues from escalating into larger problems that could be more difficult to solve later on. This will also help with productivity by minimising the risk of getting sidetracked and working on a detail which is not as important.

I also need to outline the various inputs and outputs and they will affect my game. It's important to remember the controls are likely to remain constant throughout the development process as they are a core part of the game's design. I can then determine how these inputs translate into various outputs for my game to function. Outputs can include the movement of the player and where the player shoots, for example.

## Thinking Procedurally and Decomposition

Thinking procedurally involves simplifying programming by breaking down a problem into smaller, more manageable parts: a technique known as decomposition. This approach makes it simpler to understand and design the smaller subproblems, resulting in a more efficient program. Through decomposition, a large and complicated problem can be continuously broken down into smaller subproblems that are simpler to solve.

During the design of my game, it's important that I use decomposition to streamline my workflow and prevent me from becoming overwhelmed. When the different sub-tasks come together my program should function as intended.

## Thinking Logically

Logical thinking involves analysing a situation or problem and developing potential solutions. It also involves recognising where the user needs to make decisions within the program and mapping out the potential consequences of those decisions.

There will be many choices that the player can make in my game, so the program needs to respond logically to whatever the player decides to do.

* The player may choose to buy items or powerups from the shop so the game must respond accordingly by giving the player what they purchased.
* Players can choose which weapon they use so my game needs to ensure that the gun's skin and mechanics are correct.
* The game should be constantly checking for if any controls have been pressed while ignoring any invalid key presses.
* The player could try to return to the previous rooms which they have already cleared. I need to make sure the game does not spawn enemies again.

## Thinking Concurrently

Concurrent thinking refers to the ability to accomplish multiple tasks at the same time, but it doesn't necessarily imply that you must work on several tasks simultaneously. My game will have to execute multiple tasks in each frame like updating enemy positions, drawing new models and checking for enemy deaths etc.

* Sound effects need to coincide with in-game actions for example when an enemy is killed a sound effect should be played.
* Every time the player kills an enemy or opens a chest the game needs to keep track of it so that it can be displayed at the end of the dungeon along with other relevant statistics.
* Multiple enemies will be present in the same room therefore it is important for the movement of each enemy to be operated concurrently.
* The game must keep track of how many coins and health points the player has and adjust them accordingly.
* The program needs to keep track of hitboxes to determine if they interact and react accordingly.
